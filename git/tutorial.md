# Полный туториал по Git

Содержание 

1. [Установка и настройка](#установка_и_настройка)
2. [Основы работы с Git](#основы_работы_с_git)

## Установка и настройка

Рекомендуется установить [VS Code](code.visualstudio.com) для работы с кодом и системой контроля версий

### 1. Установка Git

**На Windows:**
- Скачайте Git [с официального сайта](https://git-scm.com/book/ru/v2/%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-Git)
- Запустите установщик и следуйте инструкциям

**На Mac:**
В терминале:
- Установите [Homebrew](https://brew.sh/)
- Выполните установку git с помощью команды `brew install git`
- По завершении проверьте установку: `git --version`

Должна отобразиться версия Git, например: `git version 2.39.1`

### 2. Настройка Git

Переходим к работе в командной строке (терминале)

Как открыть терминал на Windows? Можно использовать программы git bash, cmd либо работать в терминале VS Code (View > Terminal) 

**Базовая настройка:**

Заведите аккаунт на GitHub и перейдите к настройке git на вашем компьютере

Установите ваше имя пользователя (будет отображаться в коммитах, совпадает с вашим username на GitHub):
```
git config --global user.name "Ваше Имя"
```

Укажите вашу почту, на которую вы зарегистрировали свой аккаунт на GitHub:
```
git config --global user.email "your.email@example.com"
```

Проверьте настройки: имя и почта отобразятся внизу списка:
```
git config --list
```

В некоторых версиях git: `git config list`

**Зачем это нужно:**
- Ваше имя и email идентифицируют автора коммитов. Это важно, когда вы работаете в команде, ведь у вашего проекта может быть несколько авторов
- Глобальные настройки `--global` применяются ко всем проектам, т.е. настройку вы производите только один раз, при установке и настройке git

---

## Основы работы с Git

### 3. Первый репозиторий: клонирование, изменение, коммит

Начинаем работать на github.com

Создаем новый репозиторий: https://github.com/new

Настраиваем: имя репозитория (понятное, репрезентативное), видимость (public/private), добавляем файл README (в нем будет храниться описание вашего репозитория)

Файл `.gitignore` мы добавим позже, поэтому там галочку не нажимаем

Лицензию можно добавить по желанию, обычно мы выбиарем MIT или Apache 2.0

**Клонирование репозитория:**

> Если вы используете Windows, убедитесь, что вы не клонируете репозиторий
 в системную папку, например, System32, т.к. это может затруднить работу
 с файлами. В этом случае рекомендуется перед клонирование репозитория 
 перейти в Documents.

Клонируйте существующий репозиторий

```
git clone https://github.com/username/repository-name.git
```

Перейдите в папку проекта. Далее все команды мы будем выполнять именно внутри этой папки

```
cd repository-name
```

**Работа с файлами:**

Папку, которая появится после клонирования репозитория можно найти в проводнике или finder, но также вы можете работать прямо из терминала (командной строки), а также в VS Code. Рекомендуется использовать VS Code

Создадим файл `.gitignore`. Здесь мы перечисляем все файлы и папки, которые не должны попадать в систему контроля версий, например, API-ключи, кэш, приватные данные

Например, создадим в папке файл `.gitignore` с таким содержанием:

```
__pycache__/
.vs-code/
```

Обратите внимания, что у нашего файла нет названия. Внутри него мы просто перечислили названия папок, которые хотим скрыть от "посторонних" лиц. В `__pycache__` хранятся временные файлы, которые необходимы для исполнения кода на Python, а в папке `vs-code` - файлы для работы вашей среды программирования. Они нужны только на время работы вашей программы, но при этом могут содержать данные, уязвимые к *утечкам*, например, сведения о вашем устройстве или ключи доступа к API 

# Проверьте статус репозитория

```
git status
```

Эту команду можно вызывать на любом этапе вашей работы с git. Это как бухгалтерская книга, где видно, какие записи об изменения уже зафиксированы в системе контроля версий, а какие еще предстоит "утвердить" 

Git создает список выполненных вами и вашими коллегами действий. Кто, что и в какое время делал в вашем проекте. Так можно отследить любые изменения, например, создание новой функции, обновление дизайна приложения или исправление ошибок (дебаг)

Но как эти данные попадают в git?

# Добавьте файлы в staging area (подготовка к коммиту)

```
git add .
```

Staging area - это временное хранилище информации о ваших изменениях. Представьте, что вы внесли изменения в word-документ, но еще не сохранили их

# Создайте коммит с сообщением

```
git commit -m "Добавлен README файл"
```

Теперь вы зафиксировали изменения, все равно что нажали "сохранить" в Word. Эти изменения попадут в анналы истории, т.е. в git, и их сможет увидеть ваш начальник, коллега по работе или вредный препод :)

# Отправьте изменения в удаленный репозиторий

Пока все изменения зафиксированы у вас локально, но наша цель - запушить их на GitHub, т.е. отправить на сервер прекрасного места, где обитает этот туториал. Это делается с помощью команды `push`

```
git push origin main
```

Метка `origin main` указывает ветку, куда идут изменения - это ветка `main` в удаленном репозитории. Конечно, пушить можно и на другие ветки

**Пример полного цикла:**
```
# Клонируем репозиторий
git clone https://github.com/user/my-app.git
cd my-app

# Создаем новый файл
echo "console.log('Hello World!');" > app.js

# Добавляем и коммитим
git add app.js
git commit -m "Добавлен базовый скрипт приложения"

# Отправляем изменения
git push origin main
```

Теперь вы не только знаете git, но и умеете писать `Hello, World!` на JavaScript

![](https://preview.redd.it/gitexplained-v0-0dxjidtrkste1.jpeg?width=1080&crop=smart&auto=webp&s=fa8298c9cd99d19db8f633b02a29d5bb4e89a3d2)

Вот что произойдет, если вы сделаете `commit` и `push`, позабыв про `add`

### 4. Работа с ветками

**Создание и переключение между ветками:**
```bash
# Создайте новую ветку для новой функции
git branch feature/new-button

# Переключитесь на новую ветку
git checkout feature/new-button
# Или одной командой:
git checkout -b feature/new-button

# Проверьте текущую ветку
git branch
```

**Работа в ветке:**
```bash
# Внесите изменения в файлы
echo "function newButton() { }" >> script.js

# Добавьте и закоммитьте изменения
git add script.js
git commit -m "Добавлена функция новой кнопки"
```

**Слияние веток:**
```bash
# Переключитесь на основную ветку
git checkout main

# Слейте изменения из feature ветки
git merge feature/new-button

# Если нужно, удалите ветку после слияния
git branch -d feature/new-button
```

**Пример полного цикла работы с ветками:**
```bash
# Создаем ветку для исправления бага
git checkout -b bugfix/login-issue

# Исправляем проблему
echo "// Исправлена проверка логина" >> auth.js
git add auth.js
git commit -m "Исправлена ошибка в логине"

# Возвращаемся в main и сливаем изменения
git checkout main
git merge bugfix/login-issue

# Удаляем временную ветку
git branch -d bugfix/login-issue
```

**Зачем нужны ветки:**
- Разработка новых функций без влияния на текущую версию программы, чтобы ничего не сломать
- Исправление ошибок изолированно от основного "стабильного" кода
- Параллельная работа нескольких разработчиков
